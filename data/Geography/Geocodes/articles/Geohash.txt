Geohash is a public domain geocoding system invented by Gustavo Niemeyer, which encodes a geographic location into a short string of letters and digits. It is a hierarchical spatial data structure which subdivides space into buckets of grid shape, which is one of the many applications of what is known as a Z-order curve, and generally space-filling curves. Geohashes offer properties like arbitrary precision and the possibility of gradually removing characters from the end of the code to reduce its size (and gradually lose precision). As a consequence of the gradual precision degradation, nearby places will often (but not always) present similar prefixes. The longer a shared prefix is, the closer the two places are. In February 2008, together with the announcement of the system, the inventor launched the website http://geohash.org/, which allows users to convert geographic coordinates to short URLs which uniquely identify positions on the Earth, so that referencing them in emails, forums, and websites is more convenient. To obtain the Geohash, the user provides an address to be geocoded, or latitude and longitude coordinates, in a single input box (most commonly used formats for latitude and longitude pairs are accepted), and performs the request. Besides showing the latitude and longitude corresponding to the given Geohash, users who navigate to a Geohash at geohash.org are also presented with an embedded map, and may download a GPX file, or transfer the waypoint directly to certain GPS receivers.  Links are also provided to external sites that may provide further details around the specified location. For example, the coordinate pair 57.64911,10.40744 (near the tip of the peninsula of Jutland, Denmark) produces a slightly shorter hash of u4pruydqqvj. The main usages of Geohashes are: Geohashes have also been proposed to be used for geotagging. When used in a database, the structure of geohashed data has two advantages. First, data indexed by geohash will have all points for a given rectangular area in contiguous slices (the number of slices depends on the precision required and the presence of geohash "fault lines"). This is especially useful in database systems where queries on a single index are much easier or faster than multiple-index queries. Second, this index structure can be used for a quick-and-dirty proximity search: the closest points are often among the closest geohashes. Using the hash ezs42 as an example, here is how it is decoded into a decimal latitude and longitude The first step is decoding it from base 32 using the following character map: This operation results in the bits 01101 11111 11000 00100 00010.  Assuming that counting starts at 0 in the left side, the even bits are taken for the longitude code (0111110000000), while the odd bits are taken for the latitude code (101111001001). Each binary code is then used in a series of divisions, considering one bit at a time, again from the left to the right side.  For the latitude value, the interval -90 to +90 is divided by 2, producing two intervals: -90 to 0, and 0 to +90.  Since the first bit is 1, the higher interval is chosen, and becomes the current interval. The procedure is repeated for all bits in the code.  Finally, the latitude value is the center of the resulting interval.  Longitudes are processed in an equivalent way, keeping in mind that the initial interval is -180 to +180. For example, in the latitude code 101111001001, the first bit is 1, so we know our latitude is somewhere between 0 and 90. Without any more bits, we'd guess the latitude was 45, giving us an error of ±45. Since more bits are available, we can continue with the next bit, and each subsequent bit halves this error. This table shows the effect of each bit. At each stage, the relevant half of the range is highlighted in green; a low bit selects the lower range, a high bit selects the upper range. The column “mean value” shows the latitude, simply the mean value of the range. Each subsequent bit makes this value more precise. (The numbers in the above table have been rounded to 3 decimal places for clarity) Final rounding should be done carefully in a way that So while rounding 42.605 to 42.61 or 42.6 is correct, rounding to 43 is not. Geohashes can be used to find points in proximity to each other based on a common prefix. However, edge case locations close to each other but on opposite sides of the 180 degree meridian will result in Geohash codes with no common prefix (different longitudes for near physical locations). Points close by at the North and South poles will have very different geohashes (different longitudes for near physical locations). Two close locations on either side of the Equator (or Greenwich meridian) will not have a long common prefix since they belong to different 'halves' of the world. Put simply, one location's binary latitude (or longitude) will be 011111... and the other 100000...., so they will not have a common prefix and most bits will be flipped. This can also be seen as a consequence of relying on the Z-order curve (which could more appropriately be called an N-order visit in this case) for ordering the points, as two points close-by might be visited at very different times. However, two points with a long common prefix will be close-by. In order to do a proximity search, one could compute the southwest corner (low geohash with low latitude and longitude) and northeast corner (high geohash with high latitude and longitude) of a bounding box and search for geohashes between those two. This will retrieve all points in the z-order curve between the two corners, which can be far too many points, this also breaks down at the 180 meridians and the poles. Solr uses a filter list of prefixes, by computing the prefixes of the nearest squares close to the geohash  . Since a geohash (in this implementation) is based on coordinates of longitude and latitude the distance between two geohashes reflects the distance in latitude/longitude coordinates between two points, which does not translate to actual distance, see Haversine formula. Example of non-linearity for latitude-longitude system: Note that these limitations are not due to geohashing, and not due to latitude-longitude coordinates, but due to the difficulty of mapping coordinates on a sphere (non linear and with wrapping of values, similar to modulo arithmetic) to two dimensional coordinates and the difficulty of exploring a two dimensional space uniformly. The first is related to Geographical coordinate system and Map projection, and the other to Hilbert curve and z-order curve. Once a coordinate system is found that represents points linearly in distance and wraps up at the edges, and can be explored uniformly, applying geohashing to those coordinates will not suffer from the limitations above. While it is possible to apply geohashing to an area with a cartesian coordinate system, it would then only apply to the area where the coordinate system applies. Despite those issues, there are possible workarounds, and the algorithm has been successfully used in Elasticsearch,  MongoDB,  HBase, and Accumulo  to implement proximity searches. An alternative to storing Geohashes as strings in a database are Locational codes, which are also called spatial keys and similar to QuadTiles.   The Geohash algorithm was put in the public domain by its inventor in a public announcement on February 26, 2008.  While comparable algorithms have been successfully patented  and had copyright claimed upon  , GeoHash is based on an entirely different algorithm and approach. 