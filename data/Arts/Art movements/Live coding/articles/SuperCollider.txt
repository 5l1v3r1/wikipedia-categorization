SuperCollider is an environment and programming language originally released in 1996 by James McCartney for real-time audio synthesis and algorithmic composition.   Since then it has been evolving into a system used and further developed by both scientists and artists working with sound. It is an efficient and expressive dynamic programming language providing a framework for acoustic research, algorithmic music, interactive programming  and live coding. Released under the terms of the GPLv2 in 2002, SuperCollider is free and open-source software. Starting with version 3, the SuperCollider environment has been split into two components: a server, scsynth; and a client, sclang. These components communicate using OSC (Open Sound Control).  The SC language combines the object-oriented structure of Smalltalk and features from functional programming languages with a C-family syntax.  The SC Server application supports simple C and C++ plugin APIs, making it easy to write efficient sound algorithms (unit generators), which can then be combined into graphs of calculations. Because all external control in the server happens via OSC, it is possible to use it with other languages or applications.  SuperCollider's sound generation is bundled into an optimised command-line executable (named scsynth). In most cases it is controlled from within the SuperCollider programming language, but it can be used independently. The audio server has the following features:  Supernova, an independent implementation of the Server architecture,  adds multi-processor support through explicit parallel grouping of synthesis nodes. The SuperCollider programming language is a dynamically typed, garbage-collected, single-inheritance object-oriented and functional language similar to Smalltalk,  with a syntax similar to Lisp or the C programming language. Its architecture strikes a balance between the needs of realtime computation and the flexibility and simplicity of an abstract language. Like many functional languages, it implements functions as first-class objects, which may be composed. Functions and methods can have default argument values and variable length argument lists and can be called with any order of keyword arguments. Closures are lexical, and scope is both lexical and dynamic. Further features typical of functional languages are supported, including creation of closures via partial application (explicit currying), tail call optimization, list comprehensions, and coroutines. Specifics include the implicit expansion of tuples and the stateless pattern system. Its constant-time message lookup and real-time garbage collection allows large systems to be efficient and to handle signal processing flexibly.  By supporting methods of reflective, conversational, and literate programming, SuperCollider makes it relatively easy to find new sound algorithms  and to develop custom software as well as custom frameworks. With regards to domain specific knowledge, it is both general (e.g., it allows to represent properties such as time and pitch in variable degrees of abstraction) and copious of example implementations for specific purposes.  The SuperCollider language allows users to construct cross-platform graphical user interfaces for applications. The standard class library with user interface components may be extended by a number of available frameworks. For interactive programming, the system supports programmatic access to rich-text code files. It may be used to generate vector graphics algorithmically.  Because the server is controlled using Open Sound Control (OSC), a variety of applications can be used to control the server. SuperCollider language environments (see below) are typically used, but other OSC-aware systems can be used such as Pure Data.  "Third-party" clients for the SuperCollider server exist, including rsc3, a Scheme client, hsc3, based on Haskell, ScalaCollider,  based on Scala, Overtone, based on Clojure, and Sonic Pi.  These are distinct from the development environments mentioned below because they do not provide an interface to SuperCollider's programming language, instead they communicate directly with the audio server and provide their own approaches to facilitating user expression.  SuperCollider runs on macOS, Linux, Windows, FreeBSD, and OpenSUSE. For each of these operating systems there are multiple language-editing environments and clients that can be used with SuperCollider (see below).  It has also been demonstrated that SuperCollider can run on Android  and iOS.  SuperCollider code is most commonly edited and used from within its own cross-platform IDE (which supports Linux, Mac, and Windows). Other development environments with SuperCollider support include: As a versatile dynamic programming language, SuperCollider can be used for live coding, i.e. performances which involve the performer modifying and executing code on the fly.  Specific kinds of proxies serve as high level placeholders for synthesis objects which can be swapped in and out or modified at runtime. Environments allow sharing and modification of objects and process declarations over networks.  Various extension libraries support different abstraction and access to sound objects, e.g. dewdrop_lib  allows for the live creation and modification of pseudo-classes and -objects. 