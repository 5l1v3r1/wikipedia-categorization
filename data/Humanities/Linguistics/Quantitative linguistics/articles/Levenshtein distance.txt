In information theory, linguistics and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one word into the other. It is named after the Soviet mathematician Vladimir Levenshtein, who considered this distance in 1965.  Levenshtein distance may also be referred to as edit distance, although that term may also denote a larger family of distance metrics. :32 It is closely related to pairwise string alignments. Mathematically, the Levenshtein distance between two strings                         a         ,         b                 {\displaystyle a,b}     (of length                                    |                  a                    |                          {\displaystyle |a|}     and                                    |                  b                    |                          {\displaystyle |b|}     respectively) is given by                                    lev                        a             ,             b                             ⁡         (                    |                  a                    |                  ,                    |                  b                    |                  )                 {\displaystyle \operatorname {lev} _{a,b}(|a|,|b|)}     where where                                     1                        (                            a                                i                                         ≠                            b                                j                                         )                                     {\displaystyle 1_{(a_{i}\neq b_{j})}}     is the indicator function equal to 0 when                                     a                        i                             =                    b                        j                                     {\displaystyle a_{i}=b_{j}}     and equal to 1 otherwise, and                                    lev                        a             ,             b                             ⁡         (         i         ,         j         )                 {\displaystyle \operatorname {lev} _{a,b}(i,j)}     is the distance between the first                         i                 {\displaystyle i}     characters of                         a                 {\displaystyle a}     and the first                         j                 {\displaystyle j}     characters of                         b                 {\displaystyle b}    . Note that the first element in the minimum corresponds to deletion (from                         a                 {\displaystyle a}     to                         b                 {\displaystyle b}    ), the second to insertion and the third to match or mismatch, depending on whether the respective symbols are the same. For example, the Levenshtein distance between "kitten" and "sitting" is 3, since the following three edits change one into the other, and there is no way to do it with fewer than three edits: The Levenshtein distance has several simple upper and lower bounds. These include: An example where the Levenshtein distance between two strings of the same length is strictly less than the Hamming distance is given by the pair "flaw" and "lawn". Here the Levenshtein distance equals 2 (delete "f" from the front; insert "n" at the end). The Hamming distance is 4. In approximate string matching, the objective is to find matches for short strings in many longer texts, in situations where a small number of differences is to be expected. The short strings could come from a dictionary, for instance. Here, one of the strings is typically short, while the other is arbitrarily long. This has a wide range of applications, for instance, spell checkers, correction systems for optical character recognition, and software to assist natural language translation based on translation memory. The Levenshtein distance can also be computed between two longer strings, but the cost to compute it, which is roughly proportional to the product of the two string lengths, makes this impractical.  Thus, when used to aid in fuzzy string searching in applications such as record linkage, the compared strings are usually short to help improve speed of comparisons. There are other popular measures of edit distance, which are calculated using a different set of allowable edit operations. For instance, Edit distance is usually defined as a parameterizable metric calculated with a specific set of allowed edit operations, and each operation is assigned a cost (possibly infinite). This is further generalized by DNA sequence alignment algorithms such as the Smith–Waterman algorithm, which make an operation's cost depend on where it is applied. This is a straightforward, but inefficient, recursive C implementation of a LevenshteinDistance function that takes two strings, s and t, together with their lengths, and returns the Levenshtein distance between them: This implementation is very inefficient because it recomputes the Levenshtein distance of the same substrings many times. A more efficient method would never repeat the same distance calculation. For example, the Levenshtein distance of all possible prefixes might be stored in an array d[][] where d[i][j] is the distance between the first i characters of string s and the first j characters of string t. The table is easy to construct one row at a time starting with row 0. When the entire table has been built, the desired distance is d[len_s][len_t]. Computing the Levenshtein distance is based on the observation that if we reserve a matrix to hold the Levenshtein distances between all prefixes of the first string and all prefixes of the second, then we can compute the values in the matrix in a dynamic programming fashion, and thus find the distance between the two full strings as the last value computed. This algorithm, an example of bottom-up dynamic programming, is discussed, with variants, in the 1974 article The String-to-string correction problem by Robert A. Wagner and Michael J. Fischer.  This is a straightforward pseudocode implementation for a function LevenshteinDistance that takes two strings, s of length m, and t of length n, and returns the Levenshtein distance between them: Two examples of the resulting matrix (hovering over a tagged number reveals the operation performed to get that number):     The invariant maintained throughout the algorithm is that we can transform the initial segment s[1..i] into t[1..j] using a minimum of d[i,j] operations. At the end, the bottom-right element of the array contains the answer. It turns out that only two rows of the table are needed for the construction if one does not want to reconstruct the edited input strings (the previous row and the current row being calculated). The Levenshtein distance may be calculated iteratively using the following algorithm:  This two row variant is suboptimal—the amount of memory required may be reduced to one row and one word of overhead.  Hirschberg's algorithm combines this method with divide and conquer. It can compute the optimal edit sequence, and not just the edit distance, in the same asymptotic time and space bounds.  The dynamic variant is not the ideal implementation. An adaptive approach may reduce the amount of memory required and, in the best case, may reduce the time complexity to linear in the length of the shortest string, and, in the worst case, no more than quadratic in the length of the shortest string.   The Levenshtein distance between two strings of length n can be approximated to within a factor where ε > 0 is a free parameter to be tuned, in time O(n1 + ε).  It has been shown that the Levenshtein distance of two strings of length n cannot be computed in time O(n2 - ε) for any ε greater than zero unless the strong exponential time hypothesis is false.   