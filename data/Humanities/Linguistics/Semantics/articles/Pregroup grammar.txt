Pregroup grammar (PG) is a grammar formalism intimately related to categorial grammars. Much like categorial grammar (CG), PG is a kind of type logical grammar. Unlike CG, however, PG does not have a distinguished function type. Rather, PG uses inverse types combined with its monoidal operation. A pregroup is a partially ordered algebra                         (         A         ,         1         ,         ⋅         ,                    −                        l                             ,                    −                        r                             ,         ≤         )                 {\displaystyle (A,1,\cdot ,-^{l},-^{r},\leq )}     such that                         (         A         ,         1         ,         ⋅         )                 {\displaystyle (A,1,\cdot )}     is a monoid, satisfying the following relations: The contraction and expansion relations are sometimes called  Ajdukiewicz laws. From this, it can be proven that the following equations hold:                                    x                        l                                     {\displaystyle x^{l}}     and                                    x                        r                                     {\displaystyle x^{r}}     are called the left and right adjoints of x, respectively. The symbol                         ⋅                 {\displaystyle \cdot }     and                         ≤                 {\displaystyle \leq }     are also written                         ⊗                 {\displaystyle \otimes }     and                         →                 {\displaystyle \to }     respectively. In category theory, pregroups are also known as autonomous categories  or (non-symmetric) compact closed categories.  More typically,                         x         ⋅         y                 {\displaystyle x\cdot y}     will just be represented by adjacency, i.e. as                         x         y                 {\displaystyle xy}    . A pregroup grammar consists of a lexicon of words (and possibly morphemes) L, a set of atomic types T which freely generates a pregroup, and an relation                         :                 {\displaystyle :}     that relates words to types. In simple pregroup grammars, typing is a function that maps words to only one type each. Some simple, intuitive examples using English as the language to model demonstrate the core principles behind pregroups and their use in linguistic domains. Let L = {John, Mary, the, dog, cat, met, barked, at}, let T = {N, S, N0}, and let the following typing relation holds: A sentence S that has type T is said to be grammatical if                         T         ≤         S                 {\displaystyle T\leq S}    . We can prove this by use of a chain of                         ≤                 {\displaystyle \leq }    . For example, we can prove that                                    John met Mary                  :         N         ⋅                    N                        r                             ⋅         S         ⋅                    N                        l                             ⋅         N                 {\displaystyle {\text{John met Mary}}:N\cdot N^{r}\cdot S\cdot N^{l}\cdot N}     is grammatical by proving that                         N         ⋅                    N                        r                             ⋅         S         ⋅                    N                        l                             ⋅         N         ≤         S                 {\displaystyle N\cdot N^{r}\cdot S\cdot N^{l}\cdot N\leq S}    : by first using contraction on                         N         ⋅                    N                        r                                     {\displaystyle N\cdot N^{r}}     and then again on                                    N                        l                             ⋅         N                 {\displaystyle N^{l}\cdot N}    . A more convenient notation exists, however, that indicates contractions by connecting them with a drawn link between the contracting types (provided that the links are nested, i.e. don't cross). Words are also typically placed above their types to make the proof more intuitive. The same proof in this notation is simply A more complex example proves that the dog barked at the cat is grammatical: Pregroup grammars have been introduced by Joachim Lambek in 1993 as a development of his syntactic calculus, replacing the quotients by adjoints.  Such adjoints had already been used earlier by Harris but without iterated adjoints and expansion rules. Adding such adjoints was interesting to handle more complex linguistic cases, where the fact that                                    a                        l             l                             ≠         a                 {\displaystyle a^{ll}\neq a}     is needed. It was also motivated by a more algebraic viewpoint: the definition of a pregroup is a weakening of that of a group, introducing a distinction between the left and right inverses and replacing the equality by an order. This weakening was needed because using types from a free group would not work: an adjective would get the type                         N         ⋅                    N                        −             1                             =         1                 {\displaystyle N\cdot N^{-1}=1}    , hence it could be inserted at any position in the sentence.  Pregroup grammars have then been defined and studied for various languages (or fragments of them) including English,  Italian,  French,  Persian  and Sanskrit.  Languages with a relatively free word order such as Sanskrit required to introduce commutation relations to the pregroup, using precyclicity. Because of the lack of function types in PG, the usual method of giving a semantics via the λ-calculus or via function denotations is not available in any obvious way. Instead, two different methods exist, one purely formal method that corresponds to the λ-calculus, and one denotational method analogous to (a fragment of) the tensor mathematics of quantum mechanics. The purely formal semantics for PG consists of a logical language defined according to the following rules: Some examples of terms are f(x), g(a,h(x,y)),                         g         (         x         ,         b         )         ⋅         [         x         ]                 {\displaystyle g(x,b)\cdot [x]}    . A variable x is free in a term t if [x] does not appear in t, and a term with no free variables is a closed term. Terms can be typed with pregroup types in the obvious manner. The usual conventions regarding α conversion apply. For a given language, we give an assignment I that maps typed words to typed closed terms in a way that respects the pregroup structure of the types. For the English fragment given above we might therefore have the following assignment (with the obvious, implicit set of atomic terms and function symbols): where E is the type of entities in the domain, and T is the type of truth values. Together with this core definition of the semantics of PG, we also have a reduction rules that are employed in parallel with the type reductions. Placing the syntactic types at the top and semantics below, we have For example, applying this to the types and semantics for the sentence                                    John met Mary                  :         N         ⋅         (                    N                        r                             ⋅         S         ⋅                    N                        l                             )         ⋅         N                 {\displaystyle {\text{John met Mary}}:N\cdot (N^{r}\cdot S\cdot N^{l})\cdot N}     (emphasizing the link being reduced) For the sentence                                    the dog barked at the cat                  :         (         N         ⋅                    N                        0                                   l                             )         ⋅                    N                        0                             ⋅         (                    N                        r                             ⋅         S         )         ⋅         (                    S                        r                             ⋅                    N                        r             r                             ⋅                    N                        r                             ⋅         S         ⋅                    N                        l                             )         ⋅         (         N         ⋅                    N                        0                                   l                             )         ⋅                    N                        0                                     {\displaystyle {\text{the dog barked at the cat}}:(N\cdot N_{0}^{l})\cdot N_{0}\cdot (N^{r}\cdot S)\cdot (S^{r}\cdot N^{rr}\cdot N^{r}\cdot S\cdot N^{l})\cdot (N\cdot N_{0}^{l})\cdot N_{0}}    : 