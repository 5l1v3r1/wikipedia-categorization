 In computer programming, a naming convention is a set of rules for choosing the character sequence to be used for identifiers which denote variables, types, functions, and other entities in source code and documentation. Reasons for using a naming convention (as opposed to allowing programmers to choose any character sequence) include the following: The choice of naming conventions can be an enormously controversial issue, with partisans of each holding theirs to be the best and others to be inferior. Colloquially, this is said to be a matter of dogma.  Many companies have also established their own set of conventions. Some of the potential benefits that can be obtained by adopting a naming convention include the following: The choice of naming conventions (and the extent to which they are enforced) is often a contentious issue, with partisans holding their viewpoint to be the best and others to be inferior.  Moreover, even with known and well-defined naming conventions in place, some organizations may fail to consistently adhere to them, causing inconsistency and confusion.  These challenges may be exacerbated if the naming convention rules are internally inconsistent, arbitrary, difficult to remember, or otherwise perceived as more burdensome than beneficial. Well-chosen identifiers make it significantly easier for developers and analysts to understand what the system is doing and how to fix or extend the source code to apply for new needs. For example, although the statement is syntactically correct, its purpose is not evident. Contrast this with: which implies the intent and meaning of the source code, at least to those familiar with the context of the statement. The exact rules of a naming convention depend on the context in which they are employed. Nevertheless, there are several common elements that influence most if not all naming conventions in common use today. Fundamental elements of all naming conventions are the rules related to identifier length (i.e., the finite number of individual characters allowed in an identifier). Some rules dictate a fixed numerical bound, while others specify less precise heuristics or guidelines. Identifier length rules are routinely contested in practice, and subject to much debate academically. Some considerations: It is an open research issue whether some programmers prefer shorter identifiers because they are easier to type, or think up, than longer identifiers, or because in many situations a longer identifier simply clutters the visible code and provides no perceived additional benefit. Brevity in programming could be in part attributed to: Some naming conventions limit whether letters may appear in uppercase or lowercase. Other conventions do not restrict letter case, but attach a well-defined interpretation based on letter case. Some naming conventions specify whether alphabetic, numeric, or alphanumeric characters may be used, and if so, in what sequence. A common recommendation is "Use meaningful identifiers."  A single word may not be as meaningful, or specific, as multiple words. Consequently, some naming conventions specify rules for the treatment of "compound" identifiers containing more than one word. As most programming languages do not allow whitespace in identifiers, a method of delimiting each word is needed (to make it easier for subsequent readers to interpret which characters belong to which word). Historically some early languages, notably FORTRAN (1955) and ALGOL (1958), allowed spaces within identifiers, determining the end of identifiers by context. This was abandoned in later languages due to the difficulty of tokenization. It is possible to write names by simply concatenating words, and this is sometimes used, as in mypackage for Java package names,  though legibility suffers for longer terms, so usually some form of separation is used. One approach is to delimit separate words with a nonalphanumeric character.  The two characters commonly used for this purpose are the hyphen ("-") and the underscore ("_"); e.g., the two-word name "two words" would be represented as "two-words" or "two_words".  The hyphen is used by nearly all programmers writing COBOL (1959), Forth (1970), and Lisp (1958); it is also common in Unix for commands and packages, and is used in CSS.  This convention has no standard name, though it may be referred to as lisp-case or COBOL-CASE (compare Pascal case), kebab-case, or other variants.     Of these, kebab-case, dating at least to 2012,  has achieved some currency since.   By contrast, languages in the FORTRAN/ALGOL tradition, notably languages in the C and Pascal families, used the hyphen for the subtraction infix operator, and did not wish to require spaces around it (as free-form languages), preventing its use in identifiers. An alternative is to use underscores; this is common in the C family (including Python), with lowercase words, being found for example in The C Programming Language (1978), and has come to be known as snake case. Underscores with uppercase, as in UPPER_CASE, are commonly used for C preprocessor macros, hence known as MACRO_CASE, and for environment variables in Unix, such as BASH_VERSION in bash. Sometimes this is humorously referred to as SCREAMING_SNAKE_CASE. Another approach is to indicate word boundaries using medial capitalization, called "CamelCase", "Pascal case", and many other names, thus rendering "two words" as either "twoWords" or "TwoWords". This convention is commonly used in Pascal, Java, C#, and Visual Basic. Treatment of acronyms in identifiers (e.g. the "XML" and "HTTP" in XMLHttpRequest) varies. Some dictate that they be lowercased (e.g. XmlHttpRequest) to ease typing and readability, whereas others leave them uppercased (e.g. XMLHTTPRequest) for accuracy. Some naming conventions represent rules or requirements that go beyond the requirements of a specific project or problem domain, and instead reflect a greater overarching set of principles defined by the software architecture, underlying programming language or other kind of cross-project methodology. Perhaps the most well-known is Hungarian notation, which encodes either the purpose ("Apps Hungarian") or the type ("Systems Hungarian") of a variable in its name.   For example, the prefix "sz" for the variable szName indicates that the variable is a null-terminated string. A style used for very short (8 characters and less) could be: LCCIIL01, where LC would be the application (Letters of Credit), C for COBOL, IIL for the particular process subset, and the 01 a sequence number. This sort of convention is still in active use in mainframes dependent upon JCL and is also seen in the 8.3 (maximum 8 characters with period separator followed by 3 character file type) MS-DOS style. IBM's "OF Language" was documented in an IMS (Information Management System) manual. It detailed the PRIME-MODIFIER-CLASS word scheme, which consisted of names like "CUST-ACT-NO" to indicate "customer account number". PRIME words were meant to indicate major "entities" of interest to a system. MODIFIER words were used for additional refinement, qualification and readability. CLASS words ideally would be a very short list of data types relevant to a particular application.  Common CLASS words might be: NO (number), ID (identifier), TXT (text), AMT (amount), QTY (quantity), FL (flag), CD (code), W (work) and so forth.  In practice, the available CLASS words would be a list of less than two dozen terms. CLASS words, typically positioned on the right (suffix), served much the same purpose as Hungarian notation prefixes. The purpose of CLASS words, in addition to consistency, was to specify to the programmer the data type of a particular data field. Prior to the acceptance of BOOLEAN (two values only) fields, FL (flag) would indicate a field with only two possible values. Adobe's Coding Conventions and Best Practices suggests naming standards for ActionScript that are mostly consistent with those of ECMAScript.  The style of identifiers is similar to that of Java. In Ada, the only recommended style of identifiers is Mixed_Case_With_Underscores.  In C and C++, keywords and standard library identifiers are mostly lowercase. In the C standard library, abbreviated names are the most common (e.g. isalnum for a function testing whether a character is alphanumeric), while the C++ standard library often uses an underscore as a word separator (e.g. out_of_range). Identifiers representing macros are, by convention, written using only uppercase letters and underscores (this is related to the convention in many programming languages of using all-upper-case identifiers for constants). Names containing double underscore or beginning with an underscore and a capital letter are reserved for implementation (compiler, standard library) and should not be used (e.g. __reserved or  _Reserved).   This is superficially similar to stropping, but the semantics differ: the underscores are part of the value of the identifier, rather than being quoting characters (as is stropping): the value of __foo is __foo (which is reserved), not foo (but in a different namespace). In Go, the convention is to use MixedCaps or mixedCaps rather than underscores to write multiword names.  In Java, naming conventions for identifiers have been established and suggested by various Java communities such as Sun Microsystems,  Netscape,  AmbySoft,  etc. A sample of naming conventions set by Sun Microsystems are listed below, where a name in "CamelCase" is one composed of a number of words joined without spaces, with each word's initial letter in capitals — for example "CamelCase". Variable names should be short yet meaningful. The choice of a variable name should be mnemonic —  that is, designed to indicate to the casual observer the intent of its use. One-character variable names should be avoided except for temporary "throwaway" variables. Common names for temporary variables are i, j, k, m, and n for integers; c, d, and e for characters. Java compilers do not enforce these rules, but failing to follow them may result in confusion and erroneous code. For example, widget.expand() and Widget.expand() imply significantly different behaviours: widget.expand() implies an invocation to method expand() in an instance named widget, whereas Widget.expand() implies an invocation to static method expand() in class Widget. One widely used Java coding style dictates that UpperCamelCase be used for classes and lowerCamelCase be used for instances and methods.  Recognising this usage, some IDEs, such as Eclipse, implement shortcuts based on CamelCase. For instance, in Eclipse's content assist feature, typing just the upper-case letters of a CamelCase word will suggest any matching class or method name (for example, typing "NPE" and activating content assist could suggest NullPointerException). Initialisms of three or more letters are CamelCase instead of uppercase (e.g., parseDbmXmlFromIPAddress instead of parseDBMXMLFromIPAddress). One may also set the boundary at two or more letters (e.g. parseDbmXmlFromIpAddress). The built-in JavaScript libraries use the same naming conventions as Java. Data types and constructor functions use upper camel case (RegExp, TypeError, XMLHttpRequest, DOMObject) and methods use lower camel case (getElementById, getElementsByTagNameNS, createCDATASection). In order to be consistent most JavaScript developers follow these conventions.  See also: Douglas Crockford's conventions Common practice in most Lisp dialects is to use dashes to separate words in identifiers, as in with-open-file and make-hash-table. Dynamic variable names conventionally start and end with asterisks: *map-walls*. Constants names are marked by plus signs: +map-size+.   Microsoft .NET recommends UpperCamelCase for most identifiers. (lowerCamelCase is recommended for parameters and variables) and is a shared convention for the .NET languages.  Microsoft further recommends that no type prefix hints (also known as Hungarian notation) are used.   Instead of using Hungarian notation it is recommended to end the name with the base class' name; LoginButton instead of BtnLogin.  Objective-C has a common coding style that has its roots in Smalltalk . Top-level entities, including classes, protocols, categories, as well as C constructs that are used in Objective-C programs like global variables and functions, are in UpperCamelCase with a short all-uppercase prefix denoting namespace, like NSString, UIAppDelegate, NSApp or CGRectMake. Constants may optionally be prefixed with a lowercase letter "k" like kCFBooleanTrue. Instance variables of an object use lowerCamelCase prefixed with an underscore, like _delegate and _tableView. Method names use multiple lowerCamelCase parts separated by colons that delimit arguments, like: application:didFinishLaunchingWithOptions:, stringWithFormat: and isRunning. Wirthian languages Pascal, Modula-2 and Oberon generally use Capitalized or UpperCamelCase identifiers for programs, modules, constants, types and procedures, and lowercase or lowerCamelCase identifiers for math constants, variables, formal parameters and functions.  While some dialects support underscore and dollar signs in identifiers, snake case and macro case is more likely confined to use within foreign API interfaces.  Perl takes some cues from its C heritage for conventions. Locally scoped variables and subroutine names are lowercase with infix underscores. Subroutines and variables meant to be treated as private are prefixed with an underscore. Package variables are title cased. Declared constants are all caps. Package names are camel case excepting pragmata—e.g., strict and mro—which are lowercase.     Perl 6 follows more or less the same conventions as Perl, except that it allows an infix hyphen – or an apostrophe ' (or single quote) within an identifier (but not two in a row), provided that it is followed by an alphabetic character. Perl 6 programmers thus often use kebab case in their identifiers; for example,  fish-food and don't-do-that are valid identifiers.   PHP recommendations are contained in PSR-1 (PHP Standard Recommendation 1) and PSR-2.  Python and Ruby both recommend UpperCamelCase for class names, CAPITALIZED_WITH_UNDERSCORES for constants, and lowercase_separated_by_underscores for other names. In Python, if a name is intended to be "private", it is prefixed by an underscore. Private variables are only enforced by convention in Python. Names can also be suffixed with an underscore to prevent conflict with Python keywords. Prefixing with double underscores changes behaviour in classes with regard to name mangling. Prefixing and suffixing with double underscores are reserved for "magic names" which fulfill special behaviour in Python objects.  Rust recommends UpperCamelCase for type aliases and struct, trait, enum, and enum variant names, CAPITALIZED_WITH_UNDERSCORES for constants or statics, and lowercase_separated_by_underscores for other names.  Swift has shifted its naming conventions with each individual release. However a major update with Swift 3.0 stabilised the naming conventions for lowerCamelCase across variables and function declarations. Constants are usually defined by enum types or constant parameters that are also written this way. Class and other object type declarations are UpperCamelCase. As of Swift 3.0 there have been made clear naming guidelines for the language in an effort to standardise the API naming and declaration conventions across all third party APIs.    