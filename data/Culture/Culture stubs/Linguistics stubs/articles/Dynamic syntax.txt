Dynamic Syntax  is a grammar formalism that aims to represent the real-time nature of the parsing/production process. Under the Dynamic Syntax approach, linguistic knowledge is considered to be the ability to parse spoken language in context, whilst syntax is the constraint-based way in which representations of context can be built up from words encountered in a string. While it has similarities to Combinatory categorial grammar in terms of the representations it generates, it is unique amongst grammar formalisms in that it puts word-by-word left-to-right incremental build-up of representations at the heart of the formalism, rather than incrementality only being used in external parsing algorithms. Dynamic Syntax constitutes several core components: semantic formulae and composition calculus (epsilon calculus within typed lambda calculus), trees (lambda application ordering), and tree building actions (lexical and computational actions). The semantic formulae which classical Dynamic Syntax generates are a combination of Epsilon calculus formulae and Lambda calculus terms (in recent years DS-TTR has been developed alongside DS where Record Types from the formalism Type Theory with Records (TTR)) are used - see Purver et al. (2011)).  The formulae are either simple first order logic constants such as                         j         o         h                    n           ′                          {\displaystyle john'}    , predicate terms such as                         r         u                    n           ′                  (         j         o         h                    n           ′                  )                 {\displaystyle run'(john')}     or functions such as                         λ         x         .         r         u                    n           ′                  (         x         )                 {\displaystyle \lambda x.run'(x)}    . Normal lambda calculus substitution (                        β                 {\displaystyle \beta }    -reduction)  means a function can be applied to a simple term to return a predicate such that                         (         λ         x         .         r         u                    n           ′                  (         x         )         )                   j         o         h                    n           ′                  =         r         u                    n           ′                  (         j         o         h                    n           ′                  )                 {\displaystyle (\lambda x.run'(x))~john'=run'(john')}    . The Epsilon calculus extension to first order logic is implemented in quantifiers, where                         (         ∃         x         )         A         (         x         )                   ≡                   A         (         ϵ         x                   A         )                 {\displaystyle (\exists x)A(x)\ \equiv \ A(\epsilon x\ A)}    , e.g. the string "a boy" may result in the formula                         b         o                    y           ′                  (         ϵ         x                   b         o                    y           ′                  )                 {\displaystyle boy'(\epsilon x\ boy')}     being generated. One of the basic assumptions behind DS is that natural language syntax can be seen as the progressive accumulation of transparent semantic representations with the upper goal being the construction of a logical propositional formula (a formula of type t). This process is driven by means of monotonic tree growth, representing the attempt to model the way information is processed in a time-linear, incremental, word-to-word manner. Tree growth is driven by means of requirements (indicated by the question mark (?)).  Tree growth can take place in three ways: through computational rules, lexical input and pragmatic enrichment. The language of representation in Dynamic Syntax consists of binary trees. These trees are underpinned by the Logic Of Finite Trees (LOFT, Blackburn & Meyer-Viol 1994). LOFT is an expressive modal language that allows statements to be made about any treenode from the perspective of any treenode. LOFT uses two basic tree modalities, the up and down arrow relations. These correspond to the daughter and mother relations. Left nodes are addressed as 0 nodes and right nodes are 1 nodes. By convention, nodes on the left correspond to argument nodes, i.e. nodes in which arguments are represented, whereas right nodes correspond to the functor nodes, i.e. nodes in which all the various types of predicates are represented. The rootnode is given the treenode address 0 and it is defined as the sole node that does not have a mother node.  