In computer science, time formatting and storage bugs are a class of software bugs which may cause time and date calculation or display to be improperly handled. These are most commonly manifestations of arithmetic overflow, but can also be the result of other issues. The most well-known consequence of bugs of this type is the Y2K problem, but many other milestone dates or times exist that have caused or will cause problems depending on various programming deficiencies. During the 1960s, some computer programs were written using just a single digit for the year, so that 0–9 represented the years 1960–1969. It was especially easy to write programs in the COBOL language with this limitation. The problem was identified and corrected before 1970. No problems due to this problem are known to have occurred. The fix generally was to expand the year to just two digits, owing to limitations of the storage media common in that era, tab cards and magnetic tape. On 4 January 1975, the 12-bit field that had been used for dates in the Decsystem 10 operating systems overflowed. There were numerous problems and crashes related to this bug while an alternative format was developed.  Some mainframe programs were written to encode dates as the number of days since a 'zero date' of 1 January 1900, storing them as signed 16-bit binary integers. On 18 September 1989, these programs began to fail, the date being exactly 32,768 (215) days since the zero date. Values on and after this day do not fit into a signed 16-bit integer, but overflow and return negative values. The Domain/OS clock, which is based on the number of 4-microsecond units that has occurred since 1 January 1980, rolled past 47 bits on 2 November 1997, rendering unpatched systems unusable.  In the last few months before the year 2000, two other date-related milestones occurred that received less publicity than the then-impending Y2K problem. In many programs or data sets, "9/9/99" was used as a rogue value to indicate either an unresolved date or as a terminator to indicate no further data was in the set. This raised issues upon the arrival of the actual date this represents, 9 September 1999.  The other problem was related to GPS devices: GPS dates are expressed as a week number and a day-of-week number, with the week number transmitted as a ten-bit value. This means that every 1024 weeks (about 19.6 years) after Sunday 6 January 1980 (the GPS epoch), the date resets again to that date; this happened for the first time on Sunday 22 August 1999  and will happen again on 7 April 2019 and 21 November 2038. To address this concern, modernised GPS navigation messages use a 13-bit field, which only repeats every 8,192 weeks (157 years), and will not return to zero until near the year 2137. Follow-on problems caused by certain temporary fixes to the Y2K problem will crop up at various points in the 21st century. Some programs were made Y2K-compliant by continuing to use two digit years, but picking an arbitrary year prior to which those years are interpreted as 20xx, and after which are interpreted as 19xx.  For example, a program may have been changed so that it treats two-digit year values 00–68 as referring to 2000 through 2068, and values 69–99 as referring to 1969 through 1999.  Such a program will not be able to correctly deal with years beyond 2068. For applications required to calculate the birth year (or another past year), such an algorithm has long been used to overcome the Year 1900 problem, but it has failed to recognise people over 100 years old. The SPD EEPROM on modern computer memory modules contains a single-byte binary-coded decimal (two digit) year-of-manufacture code at offset +93 (0x5D).  Due to the 18–24 month generational cycle in computer technology this should not be a problem. Some systems had problems once the year rolled over to 2010. This was dubbed by some in the media as the "Y2K+10" or "Y2.01k" problem.  The main source of problems was confusion between hexadecimal number encoding and BCD encodings of numbers. The numbers 0 through 9 are encoded in both hexadecimal and BCD as 0016 through 0916. But the decimal number 10 is encoded in hexadecimal as 0A16 and in BCD as 1016. Thus a BCD 1016 interpreted as a hexadecimal encoding erroneously represents the decimal number 16. For example, the SMS protocol uses BCD encoding for dates, so some mobile phone software incorrectly reported dates of messages as 2016 instead of 2010. Windows Mobile was the first software reported to have been affected by this glitch; in some cases WM6 changed the date of any incoming SMS message sent after 1 January 2010 from the year 2010 to 2016.   Other systems affected include EFTPOS terminals,  and the PlayStation 3 (except the Slim model).  The most important such glitch occurred in Germany, where upwards of 20 million bank cards became unusable, and with Citibank Belgium, whose digipass customer identification chips stopped working.  Taiwan officially uses the Minguo calendar, which considers the Gregorian year 1912 to be its year 1. Thus, the Gregorian year 2011 is the ROC year 100, its first 3-digit year.  The unmanned Deep Impact spaceprobe lost communication with Earth on 11 August 2013, after a clock counted 232 deciseconds (tenths of seconds) since 1 January 2000. Many Apple iOS devices with the Clock application running crashed at 00:00:00 on 1 January 2014.  Several older Samsung mobile phones with Agere chipsets (such as Samsung SGH-C170) would refuse to change dates beyond 31 December 2014; the date would automatically change to 2015, but would revert to the base date in the event of a power cycle (loss of battery power). The workaround is to use the year 1987 in lieu of 2015 as compatible with the leap year cycle to display the correct day of the week, date and month on the main screen.[note 1]  During the late 1970s, on Data General Nova and Eclipse systems, World Computer Corporation (doing credit union applications) created this date format; 16 bit date field: Dates were directly comparable using unsigned functions. No known instances of this format are in use today. The Network Time Protocol has an overflow issue related to the Year 2038 problem, which manifests itself in 2036, rather than 2038. The 64-bit timestamps used by NTP consist of a 32-bit part for seconds and a 32-bit part for fractional second, giving NTP a time scale that rolls over every 232 seconds (136 years) and a theoretical resolution of 2−32 second (233 picoseconds). NTP uses an epoch of 1 January 1900. The first rollover occurs in 2036, prior to the UNIX year 2038 problem.   The original implementation of the Unix operating system stored system time as a 32-bit signed integer representing the number of seconds past the Unix epoch: midnight UTC, 1 January 1970. This value will roll over on 19 January 2038. This problem has been addressed in most modern Unix and Unix-like operating systems by storing system time as a 64-bit signed integer, although individual applications, protocols, and file formats will still need to be changed as well. The Digital Video Broadcast system has an issue on 22 April 2038, when the 16 bits used to transmit Modified Julian Days used for electronic guide scheduling will restart from zero. The ETSI EN 300 368 specification mentions in Annex C that the provided MJD formulas are valid until 28 February 2100, but makes no mention of the limits imposed by the 16 bits used to transmit the resulting value.  Early Apple Macintosh computers store time in their real-time clocks (RTCs) and HFS filesystems as an unsigned 32-bit number of seconds since 00:00:00 on 1 January 1904. After 06:28:15 on 6 February 2040, this will wrap around to 1904.  HFS+, the default format for all of Apple's recent Macintosh computers, is also affected. The replacement Apple File System resolves this issue. Currently a widely used Apple Quicktime MOV media container has atoms with creation and modification time stored in the same format. On 17 September 2042, at 23:53:57.370496 TAI, the Time of Day Clock (TODC) on the S/370 IBM mainframe and its successors, including the current zSeries, will roll over.  The UTC time will be a few seconds earlier, due to leap seconds. The TODC is implemented as a 64-bit count of 2−12 microsecond (0.244 ns) units, and the standard base is 1 January 1900. The actual resolution depends on the model, but the format is consistent, and will, therefore, roll over after 252 microseconds. Note that IBM time base is exactly 10 seconds off TAI (it was originally defined in UTC, when that was the offset from TAI). The TODC value is accessible to user mode programs and is often used for timing and for generating unique IDs for events. While IBM has defined and implemented a longer (128-bit) hardware format on recent machines, which extends the timer on both ends by at least 8 additional bits, many programs continue to rely on the 64-bit format which remains as an accessible subset of the longer timer. The ATSC system will have an issue similar to the DVB issue described above after 2048 due to its use of signed 32-bit GPS seconds that begin from 6 January 1980. Various Texas Instruments calculators of the TI BA II Plus, TI BA II Plus Professional, TI-83, TI-84 and NSpire families support a function named dbd to calculate the number of days between dates. This function accepts dates between 1950-01-01 and 2049-12-31 only. One potential area where this will start causing problems in 2020 is in the calculation of 30-year mortgages.   Programs that store dates as the number of days since an arbitrary date (or epoch) are vulnerable to roll-over or wrap-around effects if the values are not wide enough to allow the date values to span a large enough time range expected for the application. Signed 16-bit binary values roll over after 32,768 (215) days from the epoch date, producing negative values. Some mainframe systems experienced software failures because they had encoded dates as the number of days since 1 January 1900, which produced unexpected negative day numbers on the roll-over date of 18 September 1989. Similarly, unsigned 16-bit binary days counts overflow after 65,536 (216) days, which are truncated to zero values. For software using an epoch of 1 January 1900, this will occur on 6 June 2079.  Some (if not all) Nokia phones that run Series 40 (such as the Nokia X2-00) only supports dates up to 2079-12-31 and will refuse to change dates further than 2079-12-31. The workaround is to use the year 1996 in lieu of 2080 as a compatible leap year to display the correct day of the week, date and month on the main screen. Systems storing the year as a two-digit value 00..99 internally only (like many RTCs) may rollover from 2079-12-31 to the IBM PC and DOS epoch of 1980-01-01. DOS and Windows file date API and conversion functions (such as INT 21h/AH=2Ah) officially support dates up to 2099-12-31 only (even though the underlying FAT filesystem would theoretically support dates up to 2107). Hence, DOS-based operating systems as well as applications that convert other formats to the FAT/DOS format, may show unexpected behavior starting 2100-01-01.  Calendars on the PlayStation 2 game consoles and the Nintendo DS handheld game systems will have problems as well.  Another problem will emerge at the end of 2100-02-28, as 2100 is not a leap year, but many common implementations of the leap year algorithm are incomplete or simplified and would erroneously assume it to be a leap year. This would cause the date to incorrectly roll over from 2100-02-28 to 2100-02-29 instead of directly to 2100-03-01. Many existing file formats, communications protocols, and application interfaces employ a variant of the Unix time_t date format, storing the number of seconds since the Unix Epoch (midnight UTC, 1 January 1970) as an unsigned 32-bit binary integer. This value will roll over on 7 February 2106. (This storage representation problem is independent of programs that internally store and operate on system times as 64-bit signed integer values.) The date timestamps stored in FAT filesystems, originally introduced with 86-DOS 0.42 in 1981 and carried over into MS-DOS, PC DOS, DR-DOS etc., will overflow at the end of 2107-12-31. The last modification date stamp (and with DELWATCH 2.0+ also the file deletion date stamp, and since DOS 7.0+ optionally also the last access date stamp and creation date stamp), are stored in the directory entry with the year represented as an unsigned seven bit number (0–127), relative to 1980, and thereby unable to indicate any dates in the year 2108 and beyond. The API functions defined to retrieve these dates officially only support dates up to 2099-12-31. The Go programming language has a UnixNano API that counts nanoseconds since 1970 as a 64-bit signed integer.  This value will overflow on 2262-04-11. The year 10,000 will be the first Gregorian year with five digits. Although many people at first consider this year to be so far distant that a problem of this type will never actually occur, certain classes of calculations in disciplines such as astronomy and physics already need to work with years of this magnitude and greater. These applications also have to deal with the Year zero problem. All future powers of 10 years have the potential for similar problems. Programs that process years as 16-bit values may encounter problems dealing with either the year 32,768 or 65,536, depending on whether the value is treated as a signed or unsigned integer. In the case of the year 32,768 problem, years after 32,767 may be interpreted as negative numbers, beginning with −32,768.  The year 65,536 problem is more likely to manifest itself by representing the year 65,536 as the year 0.  Certain problematic years occur so far in the future, well beyond the likely lifespan of the Earth, the Sun, humanity, and even past some predictions of the lifetime of the universe, that they are mainly referenced as matters of theoretical interest, jokes, or indications that a related problem is not truly solved for any reasonable definition of "solved". Note: these year values are based on an average year of 365.2425 days, which matches the 4/100/400 leap year rules of the commonly used Gregorian calendar. Additional adjustments to the calendar over intervals this long are unavoidable, as the actual year is currently slightly shorter (about 365.242374 days) than assumed, the length of Earth's orbit around to the Sun changes over time (tropical years are currently becoming shorter at a rate of about 0.53 seconds per century), and in any case, all of these times far exceed the likely existence of the Earth. So the year numbers should be considered approximate.  